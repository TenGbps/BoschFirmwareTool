using System;
using System.IO;
using System.Linq;
using System.Numerics;

namespace BoschFirmwareTool.Crypto
{
    internal static class RSAKey
    {
        public static readonly byte[] Modulus = {
            0xC5, 0x34, 0x46, 0x5A, 0xC5, 0xF6, 0xDD, 0x0B, 0xEE, 0xFD, 0xA5, 0xC2,
            0xAB, 0x2C, 0x56, 0xF9, 0x77, 0x30, 0x36, 0x9D, 0x43, 0x13, 0xF9, 0x1D,
            0x41, 0x0B, 0x83, 0xE1, 0x8C, 0x94, 0x71, 0x44, 0xA9, 0xB1, 0xF2, 0xC4,
            0x07, 0x78, 0x20, 0x09, 0xF0, 0x78, 0x1E, 0x43, 0x26, 0x0F, 0x23, 0x8F,
            0xC2, 0x33, 0xB0, 0x88, 0xF9, 0xA5, 0xC3, 0x2C, 0x11, 0x99, 0x6C, 0xF1,
            0x35, 0x7E, 0xF5, 0x22, 0xAC, 0x4B, 0xB9, 0x2E, 0x71, 0xE7, 0x09, 0xE5,
            0x4C, 0xDE, 0x53, 0xAD, 0x5D, 0x96, 0xEE, 0x2F, 0x88, 0x56, 0x70, 0x4D,
            0xBB, 0x91, 0xE5, 0x15, 0x53, 0x24, 0x42, 0xE0, 0xF0, 0x55, 0xCE, 0x19,
            0xD1, 0x92, 0x07, 0xE0, 0x1D, 0xC0, 0x09, 0xA4, 0x2F, 0x5F, 0x4D, 0xF5,
            0x3F, 0xB4, 0x80, 0x36, 0x74, 0x15, 0x69, 0xD2, 0x1C, 0xA4, 0x23, 0xF4,
            0xD0, 0x3C, 0x85, 0x8F, 0x02, 0x00, 0x9A, 0x48, 0x9F, 0x35, 0x67, 0x0E,
            0x72, 0x09, 0x55, 0xEF, 0x7B, 0xD6, 0xC2, 0x1D, 0x50, 0xC6, 0x7B, 0x28,
            0x97, 0xDC, 0x71, 0x32, 0x0F, 0x4D, 0x7E, 0x83, 0xDB, 0xB2, 0x15, 0xAE,
            0x2B, 0xFB, 0x6D, 0xFB, 0x58, 0x6D, 0xC5, 0x6A, 0xA3, 0xE4, 0x2C, 0x6B,
            0xA2, 0xED, 0xC4, 0x77, 0xFF, 0x45, 0x25, 0x42, 0xAB, 0x55, 0x71, 0x9D,
            0x02, 0x06, 0xEE, 0xAD, 0xE3, 0x87, 0x5B, 0xFC, 0x08, 0xF5, 0x18, 0x8B,
            0x24, 0x65, 0xF5, 0x47, 0x0B, 0xBF, 0x68, 0xB0, 0x5C, 0xF7, 0x25, 0xB9,
            0x85, 0xE2, 0xC4, 0x50, 0x2B, 0xE4, 0xF5, 0x9E, 0xD2, 0xFB, 0x35, 0x25,
            0x28, 0x82, 0xE5, 0x22, 0xBF, 0x60, 0x4A, 0x34, 0xF5, 0x48, 0xB3, 0xB9,
            0xD1, 0x99, 0x75, 0xB0, 0x95, 0xE9, 0x95, 0xEC, 0x3A, 0x85, 0xFA, 0x12,
            0xE5, 0x62, 0xF3, 0xED, 0xED, 0xD5, 0x46, 0x92, 0x2D, 0xF9, 0xC7, 0x26,
            0x74, 0xB0, 0x46, 0xE9
        };

        public static readonly int PublicExponent = 0x10001;
    }
    /// <summary>
    /// This class implements public key decryption. The C# standard library does not offer an option to perform decryption with public keys.
    /// 
    /// Note: this code is not an example of how to securely do anything with RSA. Do not reuse me.
    /// </summary>
    internal class RSA
    {
        private BigInteger _exponent;
        private BigInteger _modulus;
        private int _modulusLength; // BigInteger.GetByteCount() will return a different number if the modulus has leading zeroes.

        /// <summary>
        /// Initialize this RSA instance with a modulus and exponent. Currently supports public key decryption specifically for Bosch firmware use-cases.
        /// </summary>
        /// <param name="modulus">RSA modulus (n), in big endian format</param>
        /// <param name="exponent">RSA public exponent (e)</param>
        public RSA(ReadOnlySpan<byte> modulus, int exponent)
        {
            if (modulus == null)
                throw new ArgumentNullException(nameof(modulus));

            // Sanity check modulus length (1024/2048/4096 bit keys)
            if (modulus.Length != 128 && modulus.Length != 256 && modulus.Length != 512)
                throw new ArgumentException("modulus length must be 1024/2048/4096 bits in length");

            _modulus = new BigInteger(modulus, isUnsigned: true, isBigEndian: true);
            _modulusLength = modulus.Length;
            _exponent = new BigInteger((uint)exponent);
        }

        /// <summary>
        /// Performs RSA decryption.
        /// </summary>
        /// <returns>A byte array containing the decrypted value</returns>
        public byte[] PublicDecrypt(ReadOnlySpan<byte> source)
        {
            if (source.Length > _modulusLength)
                throw new ArgumentException("ciphertext length cannot be more than modulus length");

            var src = new BigInteger(source, isUnsigned: true, isBigEndian: true);
            var result = BigInteger.ModPow(src, _exponent, _modulus);
            var plaintext = result.ToByteArray(isUnsigned: true, isBigEndian: true);

            // Find first NULL byte, return bytes after that. Padding in PKCSv1.5 is roughly 00 | Type | Pad | 00 | Data
            // We don't get the 00 as BigInteger strips it. Sanity check for Type 0x01 or 0x02 at least.
            if (plaintext[0] != 0x1 && plaintext[0] != 0x2)
                throw new InvalidDataException("invalid padding detected");

            var data = plaintext.SkipWhile((b) =>
            {
                return b != 0;
            }).Skip(1);

            return data.ToArray();
        }
    }
}
